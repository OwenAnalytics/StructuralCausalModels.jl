var documenterSearchIndex = {"docs":
[{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"StatisticalRethinking\nCausal Inference in Statistics - a primer\nCause and Correlation in Biology\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\nSeparators and Adjustment Sets in Causal Graphs: Complete Criteria and an Algorithmic Framework","category":"page"},{"location":"versions/#Versions-1","page":"Versions","title":"Versions","text":"","category":"section"},{"location":"versions/#.1.0-1","page":"Versions","title":"0.1.0","text":"","category":"section"},{"location":"versions/#","page":"Versions","title":"Versions","text":"Version for initial commit to Julia's registry.\nIntroduction of basic functionality.\nNo support latent variables.","category":"page"},{"location":"acknowledgements/#Acknowledgements-1","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"Important links are:","category":"page"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"Dagitty\nR dagitty package\nR ggm package","category":"page"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"The latter (both the Giordini code and the Sadeghi code) has been used as the basis for the Julia implementations of e.g. shipley_test(), d_separation(), basis_set() and ancestral_graph().","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl (SCM) is a Julia package to analyse directed acyclic graphs (DAGs) as described in StatisticalRethinking, Causal Inference in Statistics and Cause and Correlation in Biology.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"My initial goal for this package is to have a way to apply SCM ideas to the examples in StatisticalRethinking.jl, i.e. a working version of basis_set(), d_separation(), pcor_test() and adjustment_sets().","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"All three above references are great introductions to the use of causal models to help in understanding confounding in statistical models. ","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl is part of the StatisticalRethinkingJulia eco system. The package, once registered, can be installed using ] add StructuralCausalModels.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Please report issues (or file a pull request) on Github if you find a problem.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Note: Version 0.1.0 of StructuralCausalModels.jl does not support latent variables.","category":"page"},{"location":"walkthrough/#Structural-Causal-Models-1","page":"Walkthrough","title":"Structural Causal Models","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"To demonstrate the fuctionality in this package, setup of the 'marks' example from the ggm R package:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir)\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\")));","category":"page"},{"location":"walkthrough/#DAG-directed-acyclic-graphs-1","page":"Walkthrough","title":"DAG - directed acyclic graphs","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"DAG() accepts either an OrderedDict, an adjacency_matrix or a ggm/dagitty string. See the ancestral_graph section below for an example using an adjacency_matrix.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Below d_string holds a ggm DAG definition.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"d_string = \"DAG(\n    mechanics ~ vectors+algebra, \n    vectors ~ algebra, \n    statistics ~ algebra+analysis, \n    analysis ~ algebra)\"\n\ndag = DAG(\"marks\", d_string; df=df);\nshow(dag)","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The d_string could also contain a dagitty causal model.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"# fig2.6.dag <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")\ndag = DAG(\"fig_2_6\", \"dag {{X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"In the REPL show(dag) will display:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"DAG object:\n\nname = \"marks\"\nvars = [:mechanics, :vectors, :algebra, :statistics, :analysis]\n\nOrderedDict{Symbol,Union{Nothing, Array{Symbol,1}, Symbol}} with 4 entries:\n  :mechanics  => [:vectors, :algebra]\n  :vectors    => :algebra\n  :statistics => [:algebra, :analysis]\n  :analysis   => :algebra","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Internally, a DAG object will always contain an OrderedDict representation of the DAG. This representation is used in all functions. In the definition of the OrderedDict, read => as ~ in regression models or <- in causal models.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Optional display the DAG using GraphViz:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"fname = ProjDir * \"/marks.dot\"\nto_graphviz(dag, fname)\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The DAG pdf is here.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"In this example a DataFrame with observed values has been provided and the related covariance matrix will be computed and stored in the DAG object:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"display(dag.s)\n\n5×5 Named Array{Float64,2}\nRows ╲ Cols │  :mechanics     :vectors     :algebra    :analysis  :statistics\n────────────┼────────────────────────────────────────────────────────────────\n:mechanics  │     305.768      127.223      101.579      106.273      117.405\n:vectors    │     127.223      172.842      85.1573      94.6729       99.012\n:algebra    │     101.579      85.1573      112.886      112.113      121.871\n:analysis   │     106.273      94.6729      112.113       220.38      155.536\n:statistics │     117.405       99.012      121.871      155.536      297.755\n","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Additional DAG related functions are adjacency_matrix(), edge_matrix() and dag_vars().","category":"page"},{"location":"walkthrough/#Importing-from-and-exporting-to-[dagitty.net](http://www.dagitty.net/dags.html#),-dagitty-and-ggm-(both-are-R-packages)-1","page":"Walkthrough","title":"Importing from and exporting to dagitty.net, dagitty and ggm (both are R packages)","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Importing is easiest using the functions from_dagitty() and from_ggm() as shown above.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"To export to dagitty.net, copy and paste the output from to_dagitty() into the Model code field on the dagitty.net web interface.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"For both R packages, copy the output from to_dagitty() or to_ggm() to R.","category":"page"},{"location":"walkthrough/#Adding-a-observations-DataFrame-or-a-covariance-matrix-1","page":"Walkthrough","title":"Adding a observations DataFrame or a covariance matrix","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Use set_dag_df!() and set_dag_cov_matrix!() for this. Note that if a DataFrame is added a covariance matrix is computed.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Although this initial version of StructuralCausalModels does not support latent variables yet, by using the keyword argument force=true no check is performed if all vertices/variables in the causal diagram are present in the DataFrame or covariance matrix.","category":"page"},{"location":"walkthrough/#Directed-separation-1","page":"Walkthrough","title":"Directed separation","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Given a causal graph dag, d_separation(dag, f, l, cond) determines if the vertices in set f are d-separated from the vertices in set l given the conditioning set cond.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Show several d_separation results for the marks model:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"f = [:statistics]; s = [:mechanics];\n\ne = d_separation(dag, f, s; cond=:algebra);\nprintln(\"d_separation($(dag.name), $f, $s; cond=:algebra) = $e\")\n\ne = d_separation(dag, f, s);\nprintln(\"d_separation($(dag.name), $f, $s) = $e\")\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics, :analysis]; cond=[:algebra]) = \");\nprintln(d_separation(dag, [:statistics], [:mechanics, :analysis]; cond=[:algebra]))","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"will produce:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"d_separation(marks, [:statistics], [:mechanics]; cond=:algebra) = false\nd_separation(marks, [:statistics], [:mechanics]) = true\nd_separation(marks, [:statistics], [:mechanics, :analysis]: cond=[:algebra]) = false","category":"page"},{"location":"walkthrough/#Basis-set-1","page":"Walkthrough","title":"Basis set","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"A minimal set of d_separation statements is called a basis_set.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"A basis_set is not necessarily unique but it is sufficient to predict the complete set of d_separation statements.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Compute the basis_set:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"bs = basis_set(dag)\ndisplay(bs)\n\nBasisSet[\n  vectors ∐ analysis | [:algebra]\n  vectors ∐ statistics | [:algebra, :analysis]\n  mechanics ∐ analysis | [:algebra, :vectors]\n  mechanics ∐ statistics | [:algebra, :vectors, :analysis]\n]","category":"page"},{"location":"walkthrough/#Adjustment-sets-1","page":"Walkthrough","title":"Adjustment sets","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The function  basis_set() provides a set of conditional independencies given the causal model. The conditioning set closes (\"blocks the flow of causal info\") all paths. The conditioning_set can be empty. It provides ways to test the chosen causal model given observational data.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The function adjustment_sets() answers a related question, i.e. how to prevent confounding in multiple regression models assuming the chosen causal model is correct.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Setup the WaffleDivorce example from StatisticalRethinking:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir) #do\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"WaffleDivorce.csv\"), delim=';');\ndf = DataFrame(\n  :s => df[:, :South],\n  :a => df[:, :MedianAgeMarriage],\n  :m => df[:, :Marriage],\n  :w => df[:, :WaffleHouses],\n  :d => df[:, :Divorce]\n);\n\nfname = scm_path(\"..\", \"examples\", \"SR\", \"SR6.4.3\", \"sr6.4.3.dot\")\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)\n\nd = OrderedDict(\n  [:a, :m, :w] => :s,\n  :d => [:w, :m, :a],\n  :m => [:a]\n);\nu = []\n\ndag = DAG(\"sr6_4_3\", d, df);\nshow(dag)\n\nadjustmentsets = adjustment_sets(dag, :w, :d)\nprintln(\"Adjustment sets for open paths: $(openpaths)\\n\")\nadjustmentsets |> display\n\nAdjustment sets:\n2-element Array{Array{Symbol,1},1}:\n [:s]\n [:a, :m]","category":"page"},{"location":"walkthrough/#Shipley-test-1","page":"Walkthrough","title":"Shipley test","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Perform the Shipley test:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"t = shipley_test(dag)\ndisplay(t)\n\n(ctest = 2.816854003338401, df = 8, pv = 0.9453198036802164)","category":"page"},{"location":"walkthrough/#Paths-1","page":"Walkthrough","title":"Paths","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Adjustment_sets is based on several path manipulations and checks:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"allpaths  = all_paths(dag, :w, :d)\nprintln(\"All paths between :w and :d:\")\nallpaths |> display\nprintln()","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"for this DAG returns:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"backdoorpaths = backdoor_paths(dag, allpaths, :w)\nprintln(\"All backdoors between :w and :d:\")\nbackdoorpaths |> display\nprintln()\n\n4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]\n","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"println(\"Show path: $(allpaths[2])\")\nshow_dag_path(dag, allpaths[2]) |> display\nprintln()\n\n\":w ⇐ :s ⇒ :a ⇒ :m ⇒ :d\"","category":"page"},{"location":"walkthrough/#Ancestral-graph-1","page":"Walkthrough","title":"Ancestral graph","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Setup an ancestral_graph example:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels, Test\n\nProjDir = @__DIR__\n\n#include(scm_path(\"test_methods\", \"test_ag.jl\"))\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n$i\") for i in 1:size(amat_data, 1)]\na = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\n\ndag = DAG(\"ag_example\", a)\n\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nfr = StructuralCausalModels.test_ag(a; m=m, c=c)\n\nfr1 = ancestral_graph(a; m=m, c=c)\n@test all(fr .== fr1)\n\nfr2 = StructuralCausalModels.test_ag(dag.a; m=m, c=c)\n@test all(fr .== fr2);\n\nprintln()\ndisplay(fr)\nprintln()","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"CurrentModule = StructuralCausalModels","category":"page"},{"location":"#scm_path-1","page":"StructuralCausalModels API","title":"scm_path","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"scm_path(parts...)","category":"page"},{"location":"#StructuralCausalModels.scm_path-Tuple","page":"StructuralCausalModels API","title":"StructuralCausalModels.scm_path","text":"scm_path\n\nRelative path using the StructuralCausalModels.jl src/ directory.\n\nExample to get access to the data subdirectory\n\nscm_path(\"..\", \"data\")\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#DAG-1","page":"StructuralCausalModels API","title":"DAG","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"DAG(name::AbstractString, model::ModelDefinition; df::DataFrameOrNothing=nothing)","category":"page"},{"location":"#StructuralCausalModels.DAG-Tuple{AbstractString,Union{AbstractString, NamedArray, OrderedDict}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.DAG","text":"DAG\n\nDirected acyclic graph constructor\n\nDAG(name, model; df)\n\n\nRequired arguments\n\n* `name::AbstractString`               : Name for the DAG object\n* `d::ModelDefinition`                 : DAG definition\n\nwhere\n\nModelDefinition = Union{OrderedDict, AbstractString, NamedArray}\n\nSee the extended help for a usage example.\n\nKeyword arguments\n\n* `df::DataFrame`                      : DataFrame with observations\n\nReturns\n\n* `dag::DAG`                           : Boolean result of test\n\nExtended help\n\nIn the definition of the OrderedDict, read => as ~ in regression models or <- in causal models, e.g.:\n\nd = OrderedDict(\n  :u => [:x, :v],\n  :s1 => [:u],\n  :w => [:v, :y],\n  :s2 => [:w]\n);\ndag = DAG(\"my_name\", d)\n\nComing from R's dagitty:\n\namat <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\n\ndag = DAG(\"my_name\", \"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\ndisplay(dag) # Show the DAG\n\nComing from R's ggm:\n\namat <- DAG(U~X+V, S1~U, W~V+Y, S2~W, order=FALSE)\n\ndag = DAG(\"my_name\", \"DAG(U~X+V, S1~U, W~V+Y, S2~W”)\ndisplay(dag) # Show the DAG\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#d_separation-1","page":"StructuralCausalModels API","title":"d_separation","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"d_separation(d::DAG, first::SymbolList, second::SymbolList; cond::SymbolListOrNothing, debug=false)","category":"page"},{"location":"#StructuralCausalModels.d_separation-Tuple{DAG,Union{Vector{Symbol}, Symbol},Union{Vector{Symbol}, Symbol}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.d_separation","text":"d_separation\n\nd_separation(d, first, second; cset, debug)\n\n\nComputes the d_separation between 2 sets of nodes conditioned on a third set.\n\nRequired arguments\n\nd_separation(\n* `d::DAG`                             : DAG\n* `first::SymbolList`                  : First set\n* `second::SymbolList`                 : Second set\n)\n\nKeyword arguments\n\n* `cset::SymbolListOrNothing=nothing`  : Conditioning set\n* `debug=false`                        : Trace execution\n\nReturns\n\n* `res::Bool`                          : Boolean result of test\n\nExtended help\n\nExample\n\nd_separation between mechanics and statistics, conditioning on algebra\n\nusing StructuralCausalModels, CSV\n\ndf = DataFrame!(CSV.File(scm_path(\"..\", \"data\", \"marks.csv\"));\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :analysis => [:algebra],\n  :statistics => [:algebra, :analysis]\n);\n\ndag = DAG(\"marks\", d, df);\nd_separation(marks, [:statistics], [:mechanics]; cset=[:algebra]))\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#shipley_test-1","page":"StructuralCausalModels API","title":"shipley_test","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"shipley_test(d::DAG)","category":"page"},{"location":"#StructuralCausalModels.shipley_test-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.shipley_test","text":"shipley_test\n\nshipley_test(d)\n\n\nTest of all independencies implied by a given DAG\n\nComputes a simultaneous test of all independence relationships implied by a given Gaussian model defined according to a directed acyclic graph, based on the sample covariance matrix.\n\nThe test statistic is C = -2 sum(ln(pj)) where pj are the p-values of tests of conditional independence in the basis set computed by basiSet(A). The p-values are independent uniform variables on (0,1) and the statistic has exactly a chi square distribution on 2k degrees of freedom where k is the number of elements of the basis set.  Shipley (2002) calls this test Fisher's C test.\n\nMethod\n\nshipley_test(;\n* `d::Dag`                             : Directed acyclic graph\n)\n\nReturns\n\n* `res::NamedTuple`                    : (ctest=..., dof=..., pval=...)\n\nwhere:\n\nctest: Test statistic C   dof:   Degrees of freedom.   pval:  The P-value of the test, assuming a two-sided alternative.\n\nExtended help\n\nExample\n\nShipley_test for the mathematics marks data\n\nusing StructuralCausalModels, RData\n\nobjs = RData.load(scm_path(\"..\", \"data\", \"marks.rda\");\nmarks_df = objs[\"marks\"]\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :statistics => [:algebra, :analysis],\n  :analysis => [:algebra]\n);\ndag = Dag(d; df=df)\nshipley_test(dag)\n\nSee also\n\n?Dag\n?basis_set\n?pcor_test\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nReferences\n\nShipley, B. (2000). A new inferential test for path models based on directed acyclic graphs. Structural Equation Modeling, 7(2), 206–218.\n\nLicence\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#basis_set-1","page":"StructuralCausalModels API","title":"basis_set","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"basis_set(dag::DAG)","category":"page"},{"location":"#StructuralCausalModels.basis_set-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.basis_set","text":"basis_set\n\nDetermine basis_set\n\nbasis_set(dag; debug)\n\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#ancestral_graph-1","page":"StructuralCausalModels API","title":"ancestral_graph","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"ancestral_graph(d::DAG; m=Symbol[], c=Symbol[])","category":"page"},{"location":"#StructuralCausalModels.ancestral_graph-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancestral_graph","text":"ancestral_graph\n\nancestral_graph(d; m, c)\n\n\nAncestral graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `d::DAG`                             : DAG onject\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `ag::NamedTuple`                     : Ancestral graph remaining\n\n\n\n\n\n","category":"method"},{"location":"#adjustment_sets-1","page":"StructuralCausalModels API","title":"adjustment_sets","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"adjustment_sets(d::DAG, f::Symbol, l::Symbol; debug=false)","category":"page"},{"location":"#StructuralCausalModels.adjustment_sets-Tuple{DAG,Symbol,Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjustment_sets","text":"adjustment_sets\n\nCompute the covariance adjustment vertex set.\n\nadjustment_sets(d, f, l; debug)\n\n\nPart of the API, Exported\n\n\n\n\n\n","category":"method"},{"location":"#paths-1","page":"StructuralCausalModels API","title":"paths","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"all_paths(d::DAG, f::Symbol, l::Symbol)\nbackdoor_paths(d::DAG, paths::Vector{Vector{Symbol}}, f::Symbol)","category":"page"},{"location":"#StructuralCausalModels.all_paths-Tuple{DAG,Symbol,Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.all_paths","text":"all_edges\n\nall_paths(d, f, l; debug)\n\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.backdoor_paths-Tuple{DAG,Vector{Vector{Symbol}},Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.backdoor_paths","text":"backdoor_paths\n\nbackdoor_paths(d, paths, f)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#Support_functions-1","page":"StructuralCausalModels API","title":"Support_functions","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"adjacency_matrix(d::OrderedDict)\nadjacency_matrix(e::NamedArray)\nadjacency_matrix_to_dict(ea::NamedArray)\nancester_graph(e::NamedArray)\nancestral_graph(a::NamedArray{Int, 2}; m=Symbol[], c=Symbol[])\ndag_show(io::IO, d::DAG)\ndag_vars(d::OrderedDict)\nedge_matrix(d::OrderedDict)\nedge_matrix(a::NamedArray, inv=false)\nindicator_matrix(e::NamedArray)\ninduced_covariance_graph(d::DAG, sel::Vector{Symbol}, cond::SymbolList; debug=false)\nnode_edges(p::Path, s::Symbol, l::Symbol)\npcor(u::Vector{Symbol}, S::NamedArray)\ntopological_order(a::NamedArray)\ntopological_sort(a::NamedArray)\ntransitive_closure(a::NamedArray)\nset_dag_df!(d::DAG, df::DataFrameOrNothing; force=false)\nset_dag_cov_matrix!(d::DAG, cm::NamedArrayOrNothing; force=false)\nundirected_matrix(d::DAG)","category":"page"},{"location":"#StructuralCausalModels.adjacency_matrix-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix","text":"adjacency_matrix\n\nadjacency_matrix(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.adjacency_matrix-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix","text":"adjacency_matrix\n\nadjacency_matrix(e)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.adjacency_matrix_to_dict-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.adjacency_matrix_to_dict","text":"adjacency_matrix_to_dict\n\nadjacency_matrix_to_dict(a)\n\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.ancester_graph-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancester_graph","text":"ancestor_graph\n\nancester_graph(e)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.ancestral_graph-Tuple{NamedMatrix{Int64,AT,DT} where DT where AT}","page":"StructuralCausalModels API","title":"StructuralCausalModels.ancestral_graph","text":"ancestral_graph\n\nancestral_graph(a; m, c)\n\n\nAncestral graphs after marginalization and conditioning.\n\nRequired arguments\n\n* `a::NamedArray{Int, 2}`              : Adjacency matrix of a DAG\n\nOptional arguments\n\n* `m::Vector{Symbol}`                  : Nodes in DAG that are marginalized\n* `c::Vector{Symbol})`                 : Nodes in DAG there are conditioned on\n\nReturns\n\n* `ag::NamedTuple`                     : Ancestral graph remaining\n\nExtended help\n\nExample\n\nAdjacency matrix used for testing in ggm\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n\\$i\") for i in 1:size(amat_data, 1)]\na = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nag = ancestral_graph(a; m = m, c = c)\n\nAcknowledgements\n\nOriginal author:                       Kayvan Sadeghi\n\nTranslated to Julia:                   Rob J Goedman\n\nReferences\n\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\n\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\n\nLicence\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the api, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.dag_show-Tuple{IO,DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.dag_show","text":"dag_show\n\ndag_show(io, d)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.dag_vars-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.dag_vars","text":"dag_vars\n\ndag_vars(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.edge_matrix-Tuple{OrderedDict}","page":"StructuralCausalModels API","title":"StructuralCausalModels.edge_matrix","text":"edge_matrix\n\nedge_matrix(d)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.edge_matrix","page":"StructuralCausalModels API","title":"StructuralCausalModels.edge_matrix","text":"edge_matrix\n\nedge_matrix(a)\nedge_matrix(a, inv)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"function"},{"location":"#StructuralCausalModels.indicator_matrix-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.indicator_matrix","text":"indicator_matrix\n\nindicator_matrix(e)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.induced_covariance_graph-Tuple{DAG,Vector{Symbol},Union{Vector{Symbol}, Symbol}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.induced_covariance_graph","text":"inducedcovariancegraph\n\ninduced_covariance_graph(d, sel, cset; debug)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.node_edges-Tuple{Path,Symbol,Symbol}","page":"StructuralCausalModels API","title":"StructuralCausalModels.node_edges","text":"node_edges\n\nnode_edges(p, s, l; debug)\n\n\nInternal.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_order-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_order","text":"topological_order\n\ntopological_order(a)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.topological_sort-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.topological_sort","text":"topological_sort\n\ntopological_sort(a)\n\n\nPart of the API, exported\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.transitive_closure-Tuple{NamedArray}","page":"StructuralCausalModels API","title":"StructuralCausalModels.transitive_closure","text":"transitive_closure\n\ntransitive_closure(a)\n\n\nInternal\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.set_dag_df!-Tuple{DAG,Union{Nothing, DataFrame}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.set_dag_df!","text":"set_dag_df!\n\nSet or update Dataframe associated to DAG\n\nset_dag_df!(d, df; force)\n\n\nRequired arguments\n\n* `d::DAG`                                  : Previously defined DAG object \n* `df::DataFrameOrNothing`                  : DataFrame associated with DAG\n)\n\nOptional arguments\n\n* `force=false`                             : Force assignment of df \n)\n\nThe force = true option can be used if the DAG involves unobserved nodes.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.set_dag_cov_matrix!-Tuple{DAG,Union{Nothing, NamedArray}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.set_dag_cov_matrix!","text":"set_dag_cov_matrix!\n\nSet or update the covariance matrix associated to DAG\n\nset_dag_cov_matrix!(d, cm; force)\n\n\nRequired arguments\n\n* `d::DAG`                                  : Previously defined DAG object \n* `cm::NamedArrayOrNothing`                 : Covariance matrix in NamedArray format\n)\n\nOptional arguments\n\n* `force=false`                             : Force assignment of df \n)\n\nThe force = true option can be used if the DAG involves unobserved nodes.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#StructuralCausalModels.undirected_matrix-Tuple{DAG}","page":"StructuralCausalModels API","title":"StructuralCausalModels.undirected_matrix","text":"undirected_matrix\n\nundirected_matrix(d)\n\n\nInternal\n\n\n\n\n\n","category":"method"}]
}
