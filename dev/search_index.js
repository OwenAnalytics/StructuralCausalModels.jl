var documenterSearchIndex = {"docs":
[{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"StatisticalRethinking\nCausal Inference in Statistics - a primer\nCause and Correlation in Biology\nSadeghi, K. (2011). Stable classes of graphs containing directed acyclic graphs.\nRichardson, T.S. and Spirtes, P. (2002).  Ancestral graph Markov models {Annals of Statistics}, 30(4), 962-1030.\nSeparators and Adjustment Sets in Causal Graphs: Complete Criteria and an Algorithmic Framework","category":"page"},{"location":"versions/#Versions-1","page":"Versions","title":"Versions","text":"","category":"section"},{"location":"versions/#.1.0-1","page":"Versions","title":"0.1.0","text":"","category":"section"},{"location":"versions/#","page":"Versions","title":"Versions","text":"Version for initial commit to Julia's registry.\nIntroduction of basic functionality.","category":"page"},{"location":"acknowledgements/#Acknowledgements-1","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"Important links are:","category":"page"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"Dagitty\nR dagitty package\nR ggm package","category":"page"},{"location":"acknowledgements/#","page":"Acknowledgements","title":"Acknowledgements","text":"The latter (both the Giordini code and the Sadeghi code) has been used as the basis for the Julia implementations of e.g. shipley_test(), d_separation(), basis_set() and ancestral_graph().","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl (SCM) is a Julia package to analyse directed acyclic graphs (DAGs) as described in StatisticalRethinking, Causal Inference in Statistics and Cause and Correlation in Biology.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"My initial goal for this package is to have a way to apply SCM ideas to the examples in StatisticalRethinking.jl, i.e. a working version of basis_set(), d_separation(), pcor_test() and adjustment_sets().","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"All three above references are great introductions to the use of causal models to help in understanding confounding in statistical models. ","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"StructuralCausalModels.jl is part of the StatisticalRethinkingJulia eco system. The package, once registered, can be installed using ] add StructuralCausalModels.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Please report issues (or file a pull request) on Github if you find a problem.","category":"page"},{"location":"walkthrough/#Structural-Causal-Models-1","page":"Walkthrough","title":"Structural Causal Models","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"To demonstrate the fuctionality in this package, setup of the 'marks' example from the ggm R package:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir)\n\ndf = CSV.read(scm_path(\"..\", \"data\", \"marks.csv\"));","category":"page"},{"location":"walkthrough/#DAG-directed-acyclic-graphs-1","page":"Walkthrough","title":"DAG - directed acyclic graphs","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"DAG() accepts either an OrderedDict, an adjacency_matrix or a ggm/dagitty string. See the ancestral_graph section below for an example using an adjacency_matrix.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Below d_string holds a ggm DAG definition.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"d_string = \"DAG(\n    mechanics ~ vectors+algebra, \n    vectors ~ algebra, \n    statistics ~ algebra+analysis, \n    analysis ~ algebra)\"\n\ndag = DAG(\"marks\", d_string, df);\nshow(dag)","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The d_string could also contain a dagitty causal model.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"# fig2.6.dag <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")\ndag = DAG(\"fig_2_6\", \"dag {{X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}\")","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"In the REPL show(dag) will display:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"DAG object:\n\nname = \"marks\"\nvars = [:mechanics, :vectors, :algebra, :statistics, :analysis]\n\nOrderedDict{Symbol,Union{Nothing, Array{Symbol,1}, Symbol}} with 4 entries:\n  :mechanics  => [:vectors, :algebra]\n  :vectors    => :algebra\n  :statistics => [:algebra, :analysis]\n  :analysis   => :algebra","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Internally, a DAG object will always contain an OrderedDict representation of the DAG. This representation is used in all functions. In the definition of the OrderedDict, read => as ~ in regression models or <- in causal models.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Optional display the DAG using GraphViz:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"fname = ProjDir * \"/marks.dot\"\nto_graphviz(dag, fname)\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"The DAG pdf is here.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"In this case a DataFrame with observed values has been provided and the related covariance matrix has been computed and stored in the DAG object:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"display(dag.s)\n\n5×5 Named Array{Float64,2}\nRows ╲ Cols │  :mechanics     :vectors     :algebra    :analysis  :statistics\n────────────┼────────────────────────────────────────────────────────────────\n:mechanics  │     305.768      127.223      101.579      106.273      117.405\n:vectors    │     127.223      172.842      85.1573      94.6729       99.012\n:algebra    │     101.579      85.1573      112.886      112.113      121.871\n:analysis   │     106.273      94.6729      112.113       220.38      155.536\n:statistics │     117.405       99.012      121.871      155.536      297.755\n","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Additional DAG related functions are adjacency_matrix(), edge_matrix(), to_ggm(), from_ggm(), to_dagitty(), from_dagitty(), set_dag_df!() and set_dag_cov_matrix!().","category":"page"},{"location":"walkthrough/#Directed-separation-1","page":"Walkthrough","title":"Directed separation","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Given a causal graph, d_separation(dag, f, l, cond) determines if the vertices in set f are d-separated from the vertices in set l given the conditioning set cond.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Show several d_separation results for the marks model:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"f = [:statistics]; s = [:mechanics]; sel = vcat(f, s)\ncond = [:algebra]\n\ne = d_separation(dag, f, s, cond)\nprintln(\"d_separation($(dag.name), $f, $s, $cond) = $e\")\n\ne = d_separation(dag, f, s)\nprintln(\"d_separation($(dag.name), $f, $s) = $e\")\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics], [:vectors]) = \")\nprintln(d_separation(dag, [:statistics], [:mechanics], [:vectors]))\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics], [:analysis, :vectors]) = \")\nprintln(d_separation(dag, [:statistics], [:mechanics], [:analysis, :vectors]))\n\nprint(\"d_separation($(dag.name), [:statistics, :analysis], [:mechanics], [:algebra]) = \")\nprintln(d_separation(dag, [:statistics, :analysis], [:mechanics], [:algebra]))\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics, :vectors], [:algebra]) = \")\nprintln(d_separation(dag, [:statistics], [:mechanics, :vectors], [:algebra]))\n\nprint(\"d_separation($(dag.name), [:statistics], [:mechanics, :analysis], [:algebra]) = \")\nprintln(d_separation(dag, [:statistics], [:mechanics, :analysis], [:algebra]))\n\nprint(\"d_separation($(dag.name), [:analysis], [:vectors]) = \")\nprintln(d_separation(dag, [:analysis], [:vectors]))\n\nprint(\"d_separation($(dag.name), [:analysis], [:vectors], [:algebra]) = \")\nprintln(d_separation(dag, [:analysis], [:vectors], [:algebra]))\n\nprint(\"d_separation($(dag.name), [:vectors], [:statistics], [:algebra]) = \")\nprintln(d_separation(dag, [:analysis], [:vectors], [:algebra]))\n\nprint(\"d_separation($(dag.name), [:statistics], [:algebra], [:analysis]) = \")\nprintln(d_separation(dag, [:statistics], [:algebra], [:analysis]))\n\nprint(\"d_separation($(dag.name), [:statistics, :analysis], [:mechanics, :vectors]) = \")\nprintln(d_separation(dag, [:statistics, :analysis], [:mechanics, :vectors]))\n\nprint(\"d_separation($(dag.name), [:statistics, :analysis], [:mechanics, :vectors], [:algebra]) = \")\nprintln(d_separation(dag, [:statistics, :analysis], [:mechanics, :vectors], [:algebra]))","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"will produce:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"d_separation(marks, [:statistics], [:mechanics], [:algebra]) = false\nd_separation(marks, [:statistics], [:mechanics]) = true\nd_separation(marks, [:statistics], [:mechanics], [:vectors]) = true\nd_separation(marks, [:statistics], [:mechanics], [:analysis, :vectors]) = true\nd_separation(marks, [:statistics, :analysis], [:mechanics], [:algebra]) = false\nd_separation(marks, [:statistics], [:mechanics, :vectors], [:algebra]) = false\nd_separation(marks, [:statistics], [:mechanics, :analysis], [:algebra]) = false\nd_separation(marks, [:analysis], [:vectors]) = true\nd_separation(marks, [:analysis], [:vectors], [:algebra]) = false\nd_separation(marks, [:vectors], [:statistics], [:algebra]) = false\nd_separation(marks, [:statistics], [:algebra], [:analysis]) = false\nd_separation(marks, [:statistics, :analysis], [:mechanics, :vectors]) = true\nd_separation(marks, [:statistics, :analysis], [:mechanics, :vectors], [:algebra]) = false","category":"page"},{"location":"walkthrough/#Basis-set-1","page":"Walkthrough","title":"Basis set","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"A minimal set of d_separation statements is called a basis_set.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"A basis_set is not necessarily unique but it is sufficient to predict the complete set of d_separation statements.","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Compute the basis_set:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"bs = basis_set(dag)\ndisplay(bs)\n\nBasisSet[\n  vectors ∐ analysis | [:algebra]\n  vectors ∐ statistics | [:algebra, :analysis]\n  mechanics ∐ analysis | [:algebra, :vectors]\n  mechanics ∐ statistics | [:algebra, :vectors, :analysis]\n]","category":"page"},{"location":"walkthrough/#Shipley-test-1","page":"Walkthrough","title":"Shipley test","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Perform the Shipley test:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"t = shipley_test(dag)\ndisplay(t)\n\n(ctest = 2.816854003338401, df = 8, pv = 0.9453198036802164)","category":"page"},{"location":"walkthrough/#Adjustment-sets-1","page":"Walkthrough","title":"Adjustment sets","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Setup the WaffleDivorce example from StatisticalRethinking:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels\n\nProjDir = @__DIR__\ncd(ProjDir) #do\n\ndf = CSV.read(scm_path(\"..\", \"data\", \"WaffleDivorce.csv\"), delim=';');\ndf = DataFrame(\n  :s => df[:, :South],\n  :a => df[:, :MedianAgeMarriage],\n  :m => df[:, :Marriage],\n  :w => df[:, :WaffleHouses],\n  :d => df[:, :Divorce]\n);\n\nfname = scm_path(\"..\", \"examples\", \"SR\", \"SR6.4.3\", \"sr6.4.3.dot\")\nSys.isapple() && run(`open -a GraphViz.app $(fname)`)\n\nd = OrderedDict(\n  [:a, :m, :w] => :s,\n  :d => [:w, :m, :a],\n  :m => [:a]\n);\nu = []\n\ndag = DAG(\"sr6_4_3\", d, df);\nshow(dag)\n\nadjustmentsets = adjustment_sets(dag, :w, :d)\nprintln(\"Adjustment sets for open paths: $(openpaths)\\n\")\nadjustmentsets |> display\n\nAdjustment sets:\n2-element Array{Array{Symbol,1},1}:\n [:s]\n [:a, :m]","category":"page"},{"location":"walkthrough/#Paths-1","page":"Walkthrough","title":"Paths","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Adjustment_sets is based on several path manipulations and checks:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"allpaths  = all_paths(dag, :w, :d)\nprintln(\"All paths between :w and :d:\")\nallpaths |> display\nprintln()","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"for this DAG returns:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"backdoorpaths = backdoor_paths(dag, allpaths, :w)\nprintln(\"All backdoors between :w and :d:\")\nbackdoorpaths |> display\nprintln()\n\n4-element Array{Array{Symbol,1},1}:\n [:w, :s, :a, :d]\n [:w, :s, :a, :m, :d]\n [:w, :s, :m, :d]\n [:w, :s, :m, :a, :d]\n","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"println(\"Show path: $(allpaths[2])\")\nshow_dag_path(dag, allpaths[2]) |> display\nprintln()\n\n\":w ⇐ :s ⇒ :a ⇒ :m ⇒ :d\"","category":"page"},{"location":"walkthrough/#Ancestral-graph-1","page":"Walkthrough","title":"Ancestral graph","text":"","category":"section"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"Setup an ancestral_graph example:","category":"page"},{"location":"walkthrough/#","page":"Walkthrough","title":"Walkthrough","text":"using StructuralCausalModels, Test\n\nProjDir = @__DIR__\n\n#include(scm_path(\"test_methods\", \"test_ag.jl\"))\n\namat_data = transpose(reshape([\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0\n], (16,16)));\n\nvars = [Symbol(\"n$i\") for i in 1:size(amat_data, 1)]\na = NamedArray(Int.(amat_data), (vars, vars), (\"Rows\", \"Cols\"));\n\ndag = DAG(\"ag_example\", a)\n\nm = [:n3, :n5, :n6, :n15, :n16];\nc = [:n4, :n7];\n\nfr = StructuralCausalModels.test_ag(a; m=m, c=c)\n\nfr1 = ancestral_graph(a; m=m, c=c)\n@test all(fr .== fr1)\n\nfr2 = StructuralCausalModels.test_ag(dag.a; m=m, c=c)\n@test all(fr .== fr2);\n\nprintln()\ndisplay(fr)\nprintln()","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"CurrentModule = StructuralCausalModels","category":"page"},{"location":"#scm_path-1","page":"StructuralCausalModels API","title":"scm_path","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"scm_path(parts...)","category":"page"},{"location":"#StructuralCausalModels.scm_path-Tuple","page":"StructuralCausalModels API","title":"StructuralCausalModels.scm_path","text":"scm_path\n\nRelative path using the StructuralCausalModels.jl src/ directory.\n\nExample to get access to the data subdirectory\n\nscm_path(\"..\", \"data\")\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#DAG-1","page":"StructuralCausalModels API","title":"DAG","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"DAG\nDAG(name::AbstractString, d::OrderedDict, df::DataFrame)","category":"page"},{"location":"#StructuralCausalModels.DAG","page":"StructuralCausalModels API","title":"StructuralCausalModels.DAG","text":"DAG\n\nDirected acyclic graph struct\n\nStruct\n\nDAG(\n* `name::AbstractString`                    : Name for the DAG object\n* `d::OrderedDictOrNothing`                 : DAG definition as an OrderedDict\n* `a::NamedArrayOrNothing`                  : Adjacency matrix\n* `e::NamedArrayOrNothing`                  : Edge matrix\n* `s::NamedArrayOrNothing`                  : Covariance matrix\n* `df::DataFrameOrNothing`                  : Variable observations\n* `vars::Vector{Symbol}`                    : Names of variables in DAG\n)\n\nPart of API, exported.\n\n\n\n\n\n","category":"type"},{"location":"#StructuralCausalModels.DAG-Tuple{AbstractString,OrderedDict,DataFrame}","page":"StructuralCausalModels API","title":"StructuralCausalModels.DAG","text":"DAG\n\nDirected acyclic graph constructor\n\nDAG(name, d, df)\n\n\nRequired arguments\n\n* `name::AbstractString`               : Name for the DAG object\n* `d`                                  : DAG definition as an\n                                           OrderedDict (see extended help)\n                                           AbstractString (as in ggm or dagitty)\n                                           AdjacencyMatrix\n\nOptional positional argument\n\n* `df::DataFrame`                      : DataFrame with observations\n\nReturns\n\n* `dag::DAG`                           : Boolean result of test\n\nExtended help\n\nIn the definition of the OrderedDict, read => as ~ in regression models or <- in causal models, e.g.:\n\nd = OrderedDict(\n  :u => [:x, :v],\n  :s1 => [:u],\n  :w => [:v, :y],\n  :s2 => [:w]\n);\ndag = DAG(\"my_name\", d)\n\nComing from R's dagitty:\n\namat <- dagitty(\"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\n\ndag = DAG(\"my_name\", \"dag { {X V} -> U; S1 <- U; {Y V} -> W; S2 <- W}”)\ndisplay(dag.a) # Show the adjacency_matrix\n\nComing from R's ggm:\n\namat <- DAG(U~X+V, S1~U, W~V+Y, S2~W, order=FALSE)\n\ndag = DAG(\"my_name\", \"DAG(U~X+V, S1~U, W~V+Y, S2~W”)\ndisplay(dag.a) # Show the adjacency_matrix\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#d_separation-1","page":"StructuralCausalModels API","title":"d_separation","text":"","category":"section"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"d_separation(d::DAG, first::SymbolList, second::SymbolList; debug=false)\nd_separation(d::DAG, first::SymbolList, second::SymbolList, cond::SymbolList; debug=false)```\n\n## shipley_test","category":"page"},{"location":"#StructuralCausalModels.d_separation-Tuple{DAG,Union{Nothing, Array{Symbol,1}, Symbol},Union{Nothing, Array{Symbol,1}, Symbol}}","page":"StructuralCausalModels API","title":"StructuralCausalModels.d_separation","text":"d_separation\n\nd_separation(d, first, second; debug)\n\n\nComputes the d_separation between 2 sets of nodes conditioned on a third set.\n\nRequired arguments\n\nd_separation(\n* `d::DAG`                             : DAG\n* `first::SymbolList`                  : First set\n* `second::SymbolList`                 : Second set\n)\n\nOptional arguments\n\n* `cond::SymbolList`                   : Conditioning set\n* `debug=false`                        : Trace execution\n\nReturns\n\n* `res::Bool`                          : Boolean result of test\n\nExtended help\n\nExample\n\nd_separation between mechanics and statistics, conditioning on algebra\n\nusing StructuralCausalModels, CSV\n\ndf = CSV.read(scm_path(\"..\", \"data\", \"marks.csv\");\n\nd = OrderedDict(\n  :mechanics => [:vectors, :algebra],\n  :vectors => [:algebra],\n  :analysis => [:algebra],\n  :statistics => [:algebra, :analysis]\n);\n\ndag = DAG(\"marks\", d, df);\nd_separation(marks, [:statistics], [:mechanics], [:algebra]))\n\nAcknowledgements\n\nOriginal author:                       Giovanni M. Marchetti\n\nTranslated to Julia:                   Rob J Goedman\n\nLicense\n\nThe R package ggm is licensed under License: GPL-2.\n\nThe Julia translation is licenced under: MIT.\n\nPart of the API, exported.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs shipley_test(d::DAG)","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"\n## basis_set","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs basis_set(dag::DAG)","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"\n## ancestral_graph","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs ancestral_graph(d::DAG; m=Symbol[], c=Symbol[])","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"\n## adjustment_sets","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs adjustment_sets(d::DAG, f::Symbol, l::Symbol; debug=false)","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"\n## paths","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs allpaths(d::DAG, f::Symbol, l::Symbol) backdoorpaths(d::DAG, paths::Vector{Vector{Symbol}}, f::Symbol)","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"\n## Support_functions","category":"page"},{"location":"#","page":"StructuralCausalModels API","title":"StructuralCausalModels API","text":"@docs adjacencymatrix(d::OrderedDict) adjacencymatrix(e::NamedArray) adjacencymatrixtodict(ea::NamedArray) ancestergraph(e::NamedArray) ancestralgraph(a::NamedArray{Int, 2}; m=Symbol[], c=Symbol[]) DAG(name::AbstractString, d::OrderedDict) DAG(name::AbstractString, str::AbstractString, df::DataFrame) DAG(name::AbstractString, str::AbstractString) DAG(name::AbstractString, a::NamedArray, df::DataFrame) DAG(name::AbstractString, a::NamedArray) dagshow(io::IO, d::DAG) dagvars(d::OrderedDict) edgematrix(d::OrderedDict) edgematrix(a::NamedArray, inv=false) indicatormatrix(e::NamedArray) inducedcovariancegraph(d::DAG, sel::Vector{Symbol}, cond::SymbolList; debug=false) nodeedges(p::Path, s::Symbol, l::Symbol) pcor(u::Vector{Symbol}, S::NamedArray) topologicalorder(a::NamedArray) topologicalsort(a::NamedArray) transitiveclosure(a::NamedArray) setdagdf!(d::DAG, df::DataFrameOrNothing; force=false) setdagcovmatrix!(d::DAG, cm::NamedArrayOrNothing; force=false) undirectedmatrix(d::DAG) ```","category":"page"}]
}
